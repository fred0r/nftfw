.\" Automatically generated by Pandoc 2.2.1
.\"
.TH "NFTFW\-CONFIG" "1" "" "" "Nftfw documentation"
.hy
.SH NAME
.PP
\f[B]nftfw\-config\f[] \[em] configuration file for the nftfw system
.SH DESCRIPTION
.PP
A standard `ini' file configures the nftfw(1) system, it's stored in
\f[I]/etc/nftfw/config.ini\f[] or
\f[I]/usr/local/etc/nftfw/config.ini\f[].
The file uses the standard conventions for commenting and makes use of
several sections.
Empty values can be specified by just using a keyword.
.PP
The program starts with a built\-in version of the settings, then reads
the \f[I]config.ini\f[] file.
As distributed, the installed file has all variables commented out using
semi\-colons.
.PP
Values for the main \f[B]nftfw\f[] script can be overridden by using the
\f[B]\-o\f[] option.
The \f[B]\-i\f[] option prints keys and values.
.PP
There are several sections in the file.
.PP
\f[B][Locations]\f[]
.PP
The locations section defines the paths to files and directories used by
the system.
The program looks in \f[I]/etc\f[] and then \f[I]/usr/local/etc\f[] for
the \f[I]nftfw\f[] directory determining the `root' key and that forms
the basis for all paths.
.PP
\f[I]sysetc\f[], \f[I]sysvar\f[] These two variables contain the control
and working files for the system:
.IP
.nf
\f[C]
\ \ sysetc\ =\ ${root}/etc/nftfw
\ \ sysvar\ =\ ${root}/var/lib/nftfw
\f[]
.fi
.PP
\f[I]nftables_conf\f[] \f[B]nftfw\f[] needs to know where the system
stores the main \f[I]nftables.conf\f[] file.
If installing a new system into root (/) you may wish to change this
value to prevent \f[B]nftfw\f[] from overwriting an extant file.
Conversely, if installing a new system into \f[I]/usr/local/etc\f[], you
will need to change this value when things are working to make sure that
\f[B]nftfw\f[] writes its settings in the correct place.
.IP
.nf
\f[C]
\ \ nftables_conf\ =\ $(root}/etc/nftables.conf
\f[]
.fi
.PP
\f[I]nftfw_init\f[] The location for the initial nft setup file
containing the framework used by the firewall.
.IP
.nf
\f[C]
\ \ nftfw_init\ =\ ${sysetc}/nftfw_init.nft
\f[]
.fi
.PP
\f[I]nftfw_base\f[] \f[I]nftfw\f[] expects to find the five working
directories, \f[I]incoming.d\f[], \f[I]outgoing.d\f[],
\f[I]blacklist.d\f[], \f[I]whitelist.d\f[] and \f[I]patterns.d\f[] under
this directory.
It you want to run the system from the Symbiosis control directory, then
the \f[I]nftfw_base\f[] option needs to be changed from the default to
\f[I]/etc/symbiosis/firewall\f[].
\f[I]Nftfw\f[] expects to find its \f[I]rule.d\f[] directory in its own
\f[I]sysetc\f[] directory.
Symbiosis files in \f[I]firewall/local.d\f[] are not supported by this
system.
To provide local changes, edit \f[I]/etc/nftfw_init.nft\f[].
.IP
.nf
\f[C]
\ \ nftfw_base\ =\ ${sysetc}
\f[]
.fi
.PP
\f[B][Owner]\f[]
.PP
\f[I]owner\f[], \f[I]group\f[] The \f[I]owner\f[] variable needs to be
set to the username of the owner of the files in
\f[I]${sysetc}/nftfw\f[].
The intention is to allow a user to have easy non\-root access to
control the firewall.
If the \f[I]group\f[] variable is empty, the group will be set to the
main group of the owner, but can be set to another group if this
assists.
The blacklist and whitelist scanners will make files owned by the user
in their control directories.
The default is to use the root user.
.IP
.nf
\f[C]
\ \ \ owner=root
\ \ \ group
\f[]
.fi
.PP
\f[B][Rules]\f[]
.PP
This section provides tailoring of the default rules used in the four
processing sections of the program when rules are not explicitly given.
.IP
.nf
\f[C]
\ \ incoming\ =\ accept
\ \ outgoing\ =\ reject
\ \ whitelist\ =\ accept
\ \ blacklist\ =\ reject
\f[]
.fi
.PP
The key on the left is a program section name and the value is the name
of a rule.
A possible choice for `reject' is the `drop' rule which simply throws
inbound packets away.
The `reject' rule jumps to a table in the initialisation script that
actively rejects the packet.
.PP
\f[B][Logging]\f[]
.PP
\f[I]logfmt\f[] Set the format of log statements (see the Python
\f[I]logging\f[] documentation for possible formats)
.IP
.nf
\f[C]
\ \ logfmt\ =\ nftfw[%(process)d]:\ %(message)s
\f[]
.fi
.PP
\f[I]loglevel\f[] Sets the level are we logging at, this value needs to
be a level name not a value.
Choose one of CRITICAL, ERROR, WARNING, INFO, DEBUG.
\f[B]nftfw\f[] uses the \f[B]\-v\f[] flag to the set this value to INFO.
.IP
.nf
\f[C]
\ \ loglevel\ =\ ERROR
\f[]
.fi
.PP
\f[I]logfacility\f[] The logging facility are we using, it needs to be a
facility name not a value.
.IP
.nf
\f[C]
\ \ logfacility\ =\ daemon
\f[]
.fi
.PP
\f[I]logprint\f[] Control printing of logged informaion.
Set to False to inhibit log printing at the console.
This value is initially set to False when the program is not talking to
a terminal.
\f[B]nftfw\f[] uses the \f[B]\-q\f[] flag to the set this value to False
and the option will suppress printing to the terminal.
.IP
.nf
\f[C]
\ \ logprint\ =\ True
\f[]
.fi
.PP
\f[I]logsyslog\f[] Set to False to inhibit syslog use.
.IP
.nf
\f[C]
\ \ logsyslog\ =\ True
\f[]
.fi
.PP
\f[B][Nft]\f[]
.PP
This section affects the nftables statements generated by the rules.
.PP
Do we want counters on the statements?
.IP
.nf
\f[C]
\ \ incoming_counter\ =\ True
\ \ outgoing_counter\ =\ True
\ \ blacklist_counter\ =\ True
\ \ whitelist_counter\ =\ True
\f[]
.fi
.PP
Do we want nftables logging?
By adding a different prefix for each of the tables, it's possible to
scan the syslog for events and get feedback from the firewall.
To stop logging, just use the name.
.IP
.nf
\f[C]
\ \ incoming_logging
\ \ outgoing_logging
\ \ blacklist_logging\ =\ Blacklist
\ \ whitelist_logging
\f[]
.fi
.PP
Two variables control the type of sets automatically generated for
blacklist and whitelist tables.
When true, \f[I]nftfw\f[] uses auto_merged, interval sets for the
blacklist or whitelist sets it makes.
This set type automatically create single entries containing an address
range for adjacent IP addresses.
The feature is desirable because it reduces the number of matches.
.PP
However, at present, the auto\-merged, interval sets can cause the
\f[I]nft\f[] program to fail in some circumstances, flagging an error.
There is a bug causing \f[I]nft\f[] to succeed in loading the set when a
full install is performed but failing when attempting a reload.
.PP
The bug has been reported to the \f[I]nftables\f[] development team, but
no fix has been generated as of the current releases.
\f[I]nftfw\f[] will work around this bug, automatically generating a
full install when an attempt at a set reload fails.
However, it seems a good idea to provide a way of turning this feature
on and default to not using the feature.
.IP
.nf
\f[C]
\ \ blacklist_set_auto_merge\ =\ False
\ \ whitelist_set_auto_merge\ =\ False
\f[]
.fi
.PP
\f[B][Whitelist]\f[]
.PP
\f[I]wtmp_file\f[] The \f[B]whitelist\f[] command scans the wtmp file,
and this variable is normally empty to use the system default.
Set \f[I]wtmp_file=utmp\f[] to use the system utmp file, otherwise set a
filename in the variable.
.IP
.nf
\f[C]
\ \ wtmp_file
\f[]
.fi
.PP
\f[I]whitelist_expiry\f[] Whitelist entries in _/etc/nftfw/whitelist.d``
are automatically expired by the number of days in this variable.
\f[B]Nftfw\f[] computes the delay as the difference between `now' and
the time on the file.
.IP
.nf
\f[C]
\ \ whitelist_expiry\ =\ 10
\f[]
.fi
.PP
\f[B][Blacklist]\f[]
.PP
Constants to manage blacklisting depend on the number of matches found
in log files for the specific IP address \- the matchcount.
The nftfwls(1) program shows the currently active blacklist and all the
information associated with each IP.
.PP
\f[I]block_after\f[] When the matchcount goes over this level,
\f[B]nftfw\f[] blocks the ip using the ports in the rule (Symbiosis used
2).
.IP
.nf
\f[C]
\ \ block_after\ =\ 10
\f[]
.fi
.PP
\f[I]block_all_after\f[] When the matchcount goes over this level,
\f[B]nftfw\f[] blocks the ip using all ports.
.IP
.nf
\f[C]
\ \ block_all_after\ =\ 100
\f[]
.fi
.PP
\f[I]expire_after\f[] \f[B]nftfw\f[] removes blocked IPs from the
\f[I]blacklist.d\f[] directory after the number of days in this value
have passed since the last incident.
Bad guys keep coming back, and sometimes re\-appear several months after
expiry.
It's useful to have feedback from the firewall to keep them in play
while they batter at the firewall door.
The system allows for this, see nftfw_files(5) for information on
patterns that support feedback.
.IP
.nf
\f[C]
\ \ expire_after\ =\ 10
\f[]
.fi
.PP
Symbiosis used 2 for this value.
.PP
\f[I]clean_before\f[] \f[B]nftfw blacklist\f[] will remove ip from the
database where there has been no error posted for more than these number
of day, the intention is to keep the database from growing to huge
proportions.
A zero value will inhibit this action.
.IP
.nf
\f[C]
\ clean_before\ =\ 90
\f[]
.fi
.PP
\f[I]sync_check\f[] \f[B]nftfw blacklist\f[] will check whether the IP
addresses in the database that should be active are actually present in
the blacklist directory \f[I]blacklist.d\f[].
`Should be active' means that the addresses have not been automatically
expired.
\f[B]nftfw\f[] is largely event driven, but events get missed.
So on the basis that if stuff can happen, it will, this code will
recover the correct state of the blacklist directory.
It seems overkill to call this every time the blacklist scanner runs, so
it is executed when number of runs of the scanner is greater than the
value of this variable.
The default is to run the blacklist scanner 96 times a day, so 50 seems
are reasonable way to run the recovery code once a day.
Set this to zero to turn this feature off.
.IP
.nf
\f[C]
\ sync_check\ =\ 50
\f[]
.fi
.PP
\f[B][Nftfwls]\f[]
.PP
\f[I]date_fmt\f[] Allows change of date format for \f[I]nftfwls\f[].
The default is DD\-MM\-YYYY HH:MM:SS.
I'm using a two digit year number.
.IP
.nf
\f[C]
\ \ date_fmt\ =\ %d\-%m\-%Y\ %H:%M:%S
\f[]
.fi
.PP
\f[I]pattern_split\f[] Replaces any commas in the pattern listing column
by a newline and a space, reducing output width on the terminal output.
Can be overridden by \f[I]\-p\f[] option to \f[I]nftfwls\f[].
.IP
.nf
\f[C]
\ \ pattern_split\ =\ No
\f[]
.fi
.PP
\f[B][Nftfwedit]\f[]
.PP
The \f[I]nftfwedit\f[] print function can lookup the IP supplied as an
argument in various DNS blocklists.
The function is not enabled until entries are supplied in this section
of the config file.
The Python 3 package \f[I]python3_dnspython\f[] must also be installed.
I also suggest that your system runs a caching nameserver.
.PP
Sample entries are supplied in the distributed file, and require
un\-commenting by removing the initial semi\-colon.
The entry is \f[I]Name=domainname\f[], where the \f[I]domainname\f[] is
used to access the list in the DNS lookup.
.IP
.nf
\f[C]
\ \ ;SpamHaus=zen.spamhaus.org
\ \ ;Barracuda=b.barracudacentral.org
\ \ ;SpamCop=bl.spamcop.net
\f[]
.fi
.SH FILES
.PP
Files can be located in \f[I]/\f[] rather than \f[I]/usr/local\f[].
.TP
.B \f[I]/usr/local/etc/nftfw\f[]
Location of control files
.RS
.RE
.TP
.B \f[I]/usr/local/var/lib/nftfw/\f[]
Location of \f[I]build\f[], \f[I]install\f[], lock file and sqlite3
databases storing file positions and blacklist information
.RS
.RE
.SH BUGS
.PP
See GitHub Issues: <https://github.com/pcollinson/nftfw/issues>
.SH AUTHOR
.PP
Peter Collinson (huge credit to the ideas from Patrick Cherry's work for
the firewall for the Symbiosis hosting system).
.SH SEE ALSO
.PP
\f[B]nft(1)\f[], \f[B]nftfw(1)\f[], \f[B]nftfwls(1)\f[],
\f[B]nftfwedit(1)\f[], \f[B]nftfwadm(1)\f[], \f[B]nftfw\-files(5)\f[]
